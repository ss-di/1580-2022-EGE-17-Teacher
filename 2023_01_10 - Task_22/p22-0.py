def calc(proc, k):
	if proc[k][2] != -1:			# если время уже посчитано
		return						# выходим
	t = proc[k][0]					# время на текущий процесс
	A = proc[k][1]					# список дочерних процессов
	if A[0] == 0:					# если процесс не зависит от других
		proc[k][2] = t				# его врем завершения t
		return						# выходим
	# найдем максимальное время завершения дочерних процессов
	mx = 0							# начальный максимум
	for p in A:						# для всех дочерних процессов
		calc(proc, p)				# вычислим время завершения
		mx = max(mx, proc[p][2])	# ищем максимальное время завершения
	proc[k][2] = mx + t

with open('22-0.csv') as f:	# откроем файл
	data = f.readlines()	# прочитаем данные в массив

del data[0] # удалим строку заголовков

proc = {} # словарь в котором будем хранить данные

for d in data: # проходим по строкам файла
	m = d.split(",") # разделяем её по полям (ячейкам)
	# записываем в словарь:
	# ключ - номер процесса B
	# [0] - время на выполнение процесса B
	# [1] - список процессов А
	# [2] - время завершения процесса B (-1 - не готово)
	proc[int(m[0])] = [int(m[1]), list(map(int, m[2].split(";"))), -1]

for k in proc.keys():	# для всех процессов
	calc(proc, k)		# вычислим время завершения

# найдем максимальное время завершения всех процессов
mx = 0 # начальный максимум
for k in proc.keys(): # для всех процессов
	mx = max(mx, proc[k][2]) # ищем максимальное время завершения

print(mx) # выводим ответ
for k in proc.keys():
    print(k, proc[k])
